<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>P2P File Sharing</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
            line-height: 1.6;
        }
        #connection-section, #file-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        input, button {
            margin: 10px 0;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #log {
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            background-color: white;
        }
        #received-files a {
            color: #1a73e8;
            text-decoration: none;
        }
        #received-files a:hover {
            text-decoration: underline;
        }
        .progress-bar {
            width: 100%;
            background-color: #e0e0e0;
            padding: 3px;
            border-radius: 3px;
            margin: 10px 0;
        }
        .progress-bar-fill {
            height: 20px;
            background-color: #4CAF50;
            border-radius: 3px;
            width: 0%;
            transition: width 0.5s ease-in-out;
        }
        .error {
            color: #d32f2f;
        }
        .warning {
            color: #ffa000;
        }
        .success {
            color: #388e3c;
        }
    </style>
</head>
<body>
    <h1>P2P File Sharing</h1>
    
    <div id="connection-section">
        <h2>Connection Setup</h2>
        <input type="text" id="peer-id" placeholder="Your Unique Peer ID (e.g., Device1)">
        <input type="text" id="target-peer-id" placeholder="Target Peer ID to Connect">
        <button id="connect-btn">Connect</button>
        <p id="connection-status">Not Connected</p>
        <div id="log" class="log"></div>
    </div>

    <div id="file-section" style="display:none;">
        <h2>File Transfer</h2>
        <input type="file" id="file-input" multiple>
        <button id="send-file-btn" disabled>Send File(s)</button>
        
        <div id="file-list">
            <h3>Received Files:</h3>
            <ul id="received-files"></ul>
        </div>
    </div>

    <!-- Polyfills for older browsers -->
    <script src="https://cdn.jsdelivr.net/npm/webrtc-adapter@latest/dist/adapter.min.js"></script>

    <script>
    // Feature detection
    if (!window.RTCPeerConnection || !navigator.mediaDevices) {
        document.getElementById('log').innerHTML = 
            '<div class="error">WebRTC not supported in this browser. Please use Chrome/Firefox/Edge latest version.</div>';
        throw new Error("WebRTC unsupported");
    }

    class WebRTCFileSharing {
        constructor() {
            // Configuration
            this.AUTH_TOKEN = "your-auth-token-here"; // Must match server token
            this.SIGNALING_SERVER = 'wss://82.34.178.68:8443/ws';
            this.configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' }
                ]
            };
            this.CHUNK_SIZE = 16 * 1024; // 16KB chunks for better performance
            
            // State management
            this.peerConnection = null;
            this.dataChannel = null;
            this.socket = null;
            this.receivedFiles = [];
            this.currentFileBuffer = [];
            this.currentFileInfo = null;
            this.fileTransferProgress = {};
            
            this.initialize();
        }

        initialize() {
            this.initializeDOMElements();
            this.initializeEventListeners();
            this.initializeTURNServers();
        }

        initializeDOMElements() {
            this.elements = {
                peerIdInput: document.getElementById('peer-id'),
                targetPeerIdInput: document.getElementById('target-peer-id'),
                connectBtn: document.getElementById('connect-btn'),
                connectionStatus: document.getElementById('connection-status'),
                logElement: document.getElementById('log'),
                fileSection: document.getElementById('file-section'),
                fileInput: document.getElementById('file-input'),
                sendFileBtn: document.getElementById('send-file-btn'),
                receivedFilesList: document.getElementById('received-files')
            };
        }

        initializeEventListeners() {
            this.elements.connectBtn.addEventListener('click', () => this.handleConnect());
            this.elements.sendFileBtn.addEventListener('click', () => this.handleFileSend());
            window.addEventListener('beforeunload', () => this.cleanup());
        }

        async initializeTURNServers() {
            try {
                const response = await fetch('https://global.xirsys.net/_turn/TreggWEBRTC', {
                    method: 'PUT',
                    headers: {
                        'Authorization': 'Basic ' + btoa("TreggJr:f6bc9368-f6b8-11ef-97c7-0242ac150003"),
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({"format": "urls"})
                });

                const data = await response.json();
                if (data.v?.iceServers) {
                    this.configuration.iceServers = this.configuration.iceServers.concat(
                        data.v.iceServers.urls.map(url => ({
                            urls: url,
                            username: data.v.iceServers.username,
                            credential: data.v.iceServers.credential
                        }))
                    );
                    this.log('TURN servers initialized', 'success');
                }
            } catch (error) {
                this.log('Using STUN servers only: ' + error.message, 'warning');
            }
        }

        handleConnect() {
            const peerId = this.elements.peerIdInput.value.trim();
            const targetPeerId = this.elements.targetPeerIdInput.value.trim();
            
            if (!peerId) {
                this.log('Please enter a Peer ID', 'error');
                return;
            }

            this.setupWebSocketConnection(peerId, targetPeerId);
        }

        setupWebSocketConnection(peerId, targetPeerId) {
            try {
                this.socket = new WebSocket(this.SIGNALING_SERVER);

                this.socket.onopen = () => {
                    this.log('Authenticating with signaling server...');
                    // First message must be authentication
                    this.socket.send(JSON.stringify({
                        type: 'authenticate',
                        token: this.AUTH_TOKEN,
                        peerId: peerId
                    }));
                };

                this.socket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        
                        if (message.type === 'auth_success') {
                            this.log('Authentication successful', 'success');
                            this.handleSignalingMessage({
                                type: 'register',
                                peerId: peerId,
                                targetPeerId: targetPeerId || null
                            });
                            return;
                        }
                        
                        this.handleSignalingMessage(message);
                    } catch (error) {
                        this.logError('Message handling error', error);
                    }
                };

                this.socket.onerror = (error) => {
                    this.logError('WebSocket error', error);
                    this.elements.connectionStatus.textContent = 'Connection failed';
                };

                this.socket.onclose = (event) => {
                    const reason = event.reason || 'Unknown reason';
                    this.log(`Disconnected: ${reason} (Code ${event.code})`, 'warning');
                    this.elements.connectionStatus.textContent = 'Disconnected';
                    this.elements.sendFileBtn.disabled = true;
                    this.elements.fileSection.style.display = 'none';
                    
                    // Attempt reconnection after 5 seconds
                    if (event.code !== 1000) {
                        setTimeout(() => {
                            const peerId = this.elements.peerIdInput.value.trim();
                            const targetPeerId = this.elements.targetPeerIdInput.value.trim();
                            if (peerId) this.setupWebSocketConnection(peerId, targetPeerId);
                        }, 5000);
                    }
                };

            } catch (error) {
                this.logError('WebSocket connection failed', error);
            }
        }

        handleSignalingMessage(message) {
            switch(message.type) {
                case 'offer':
                    this.handleOffer(message);
                    break;
                case 'answer':
                    this.handleAnswer(message);
                    break;
                case 'ice-candidate':
                    this.handleIceCandidate(message);
                    break;
                case 'error':
                    this.log(message.message || 'Unknown error', 'error');
                    break;
                default:
                    this.log(`Unknown message type: ${message.type}`);
            }
        }

        async createPeerConnection() {
            this.peerConnection = new RTCPeerConnection(this.configuration);
            
            this.dataChannel = this.peerConnection.createDataChannel("fileTransfer", {
                ordered: true,
                maxPacketLifeTime: 3000
            });
            
            this.setupDataChannelHandlers();

            this.peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    this.socket.send(JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate
                    }));
                }
            };

            this.peerConnection.oniceconnectionstatechange = () => {
                const state = this.peerConnection.iceConnectionState;
                this.log(`ICE connection state: ${state}`);
                if (state === 'disconnected' || state === 'failed') {
                    this.cleanupPeerConnection();
                }
            };

            this.peerConnection.ondatachannel = (event) => {
                this.dataChannel = event.channel;
                this.setupDataChannelHandlers();
            };
        }

        setupDataChannelHandlers() {
            this.dataChannel.onopen = () => {
                this.elements.connectionStatus.textContent = 'Connected (P2P)';
                this.elements.sendFileBtn.disabled = false;
                this.elements.fileSection.style.display = 'block';
                this.log('Data channel ready for file transfer', 'success');
            };

            this.dataChannel.onclose = () => {
                this.log('Data channel closed', 'warning');
                this.elements.connectionStatus.textContent = 'Disconnected';
                this.elements.sendFileBtn.disabled = true;
            };

            this.dataChannel.onmessage = (event) => {
                this.handleIncomingMessage(event.data);
            };

            this.dataChannel.onerror = (error) => {
                this.logError('Data channel error', error);
            };
        }

        async handleOffer(message) {
            try {
                await this.createPeerConnection();
                await this.peerConnection.setRemoteDescription(
                    new RTCSessionDescription(message.offer)
                );
                
                const answer = await this.peerConnection.createAnswer();
                await this.peerConnection.setLocalDescription(answer);
                
                this.socket.send(JSON.stringify({
                    type: 'answer',
                    sourcePeerId: message.targetPeerId,
                    targetPeerId: message.sourcePeerId,
                    answer: answer
                }));
            } catch (error) {
                this.logError('Offer handling failed', error);
            }
        }

        async handleAnswer(message) {
            try {
                if (!this.peerConnection) {
                    throw new Error('No active peer connection');
                }
                await this.peerConnection.setRemoteDescription(
                    new RTCSessionDescription(message.answer)
                );
            } catch (error) {
                this.logError('Answer handling failed', error);
            }
        }

        async handleIceCandidate(message) {
            try {
                if (!this.peerConnection) return;
                await this.peerConnection.addIceCandidate(
                    new RTCIceCandidate(message.candidate)
                );
            } catch (error) {
                this.logError('ICE candidate error', error);
            }
        }

        handleFileSend() {
            const files = this.elements.fileInput.files;
            if (!files.length || !this.dataChannel || 
                this.dataChannel.readyState !== 'open') return;
                
            Array.from(files).forEach(file => this.sendFile(file));
        }

        sendFile(file) {
            const fileInfo = {
                name: file.name,
                size: file.size,
                type: file.type,
                lastModified: file.lastModified
            };

            this.fileTransferProgress[fileInfo.name] = {
                sent: 0,
                total: fileInfo.size
            };

            // Send file metadata first
            this.dataChannel.send(JSON.stringify({
                type: 'fileInfo',
                data: fileInfo
            }));

            const reader = new FileReader();
            let offset = 0;

            const readNextChunk = () => {
                const slice = file.slice(offset, offset + this.CHUNK_SIZE);
                reader.readAsArrayBuffer(slice);
            };

            reader.onload = (e) => {
                const chunk = e.target.result;
                this.dataChannel.send(JSON.stringify({
                    type: 'fileChunk',
                    name: fileInfo.name,
                    data: Array.from(new Uint8Array(chunk)),
                    offset: offset
                }));

                offset += chunk.byteLength;
                this.fileTransferProgress[fileInfo.name].sent = offset;

                // Update progress
                const percent = Math.round((offset / fileInfo.size) * 100);
                this.log(`Sending ${fileInfo.name}: ${percent}%`);
                
                if (offset < fileInfo.size) {
                    readNextChunk();
                } else {
                    this.log(`Finished sending ${fileInfo.name}`, 'success');
                    delete this.fileTransferProgress[fileInfo.name];
                }
            };

            reader.onerror = (error) => {
                this.logError('File read error', error);
            };

            readNextChunk();
            this.log(`Starting transfer of ${file.name} (${this.formatFileSize(file.size)})`);
        }

        handleIncomingMessage(message) {
            try {
                const data = JSON.parse(message);
                
                switch(data.type) {
                    case 'fileInfo':
                        this.currentFileInfo = data.data;
                        this.currentFileBuffer = [];
                        
                        // Create progress UI
                        const progressContainer = document.createElement('div');
                        progressContainer.id = `progress-${this.currentFileInfo.name}`;
                        progressContainer.innerHTML = `
                            <p>Receiving: ${this.currentFileInfo.name}</p>
                            <div class="progress-bar">
                                <div class="progress-bar-fill" style="width: 0%"></div>
                            </div>
                        `;
                        this.elements.receivedFilesList.appendChild(progressContainer);
                        break;
                        
                    case 'fileChunk':
                        if (!this.currentFileInfo) return;
                        
                        this.currentFileBuffer.push(...data.data);
                        const receivedBytes = this.currentFileBuffer.length;
                        const totalBytes = this.currentFileInfo.size;
                        
                        // Update progress
                        const percent = Math.round((receivedBytes / totalBytes) * 100);
                        const progressBar = document.querySelector(
                            `#progress-${this.currentFileInfo.name} .progress-bar-fill`
                        );
                        if (progressBar) progressBar.style.width = `${percent}%`;
                        
                        // Check if transfer complete
                        if (receivedBytes >= totalBytes) {
                            this.saveReceivedFile();
                        }
                        break;
                }
            } catch (error) {
                this.logError('Message processing error', error);
            }
        }

        saveReceivedFile() {
            if (!this.currentFileInfo) return;
            
            const blob = new Blob([new Uint8Array(this.currentFileBuffer)], {
                type: this.currentFileInfo.type
            });
            
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = this.currentFileInfo.name;
            link.textContent = `${this.currentFileInfo.name} (${this.formatFileSize(this.currentFileInfo.size)})`;
            
            const listItem = document.createElement('li');
            listItem.appendChild(link);
            this.elements.receivedFilesList.appendChild(listItem);
            
            // Clean up
            const progressContainer = document.getElementById(`progress-${this.currentFileInfo.name}`);
            if (progressContainer) progressContainer.remove();
            
            this.receivedFiles.push(this.currentFileInfo);
            this.currentFileInfo = null;
            this.currentFileBuffer = [];
            
            this.log(`File received successfully`, 'success');
        }

        formatFileSize(bytes) {
            if (bytes < 1024) return `${bytes} bytes`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
        }

        log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            entry.className = type;
            this.elements.logElement.appendChild(entry);
            this.elements.logElement.scrollTop = this.elements.logElement.scrollHeight;
        }

        logError(context, error) {
            const message = `${context}: ${error.message || error}`;
            this.log(message, 'error');
            console.error(context, error);
        }

        cleanupPeerConnection() {
            if (this.dataChannel) {
                this.dataChannel.close();
                this.dataChannel = null;
            }
            if (this.peerConnection) {
                this.peerConnection.close();
                this.peerConnection = null;
            }
        }

        cleanup() {
            if (this.socket) {
                this.socket.close();
                this.socket = null;
            }
            this.cleanupPeerConnection();
        }
    }

    // Initialize with error handling
    document.addEventListener('DOMContentLoaded', () => {
        try {
            new WebRTCFileSharing();
        } catch (error) {
            console.error("Initialization error:", error);
            document.getElementById('log').innerHTML = 
                `<div class="error">Initialization failed: ${error.message}</div>`;
        }
    });
    </script>
</body>
</html>