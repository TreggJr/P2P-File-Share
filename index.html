<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>P2P File Sharing</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
            line-height: 1.6;
        }
        #connection-section, #file-section {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        input, button {
            margin: 10px 0;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #log {
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            background-color: white;
        }
        #received-files a {
            color: #1a73e8;
            text-decoration: none;
        }
        #received-files a:hover {
            text-decoration: underline;
        }
        .progress-bar {
            width: 100%;
            background-color: #e0e0e0;
            padding: 3px;
            border-radius: 3px;
            margin: 10px 0;
        }
        .progress-bar-fill {
            height: 20px;
            background-color: #4CAF50;
            border-radius: 3px;
            width: 0%;
            transition: width 0.5s ease-in-out;
        }
    </style>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
    <h1>P2P File Sharing</h1>
    
    <div id="connection-section">
        <h2>Connection Setup</h2>
        <input type="text" id="peer-id" placeholder="Your Unique Peer ID (e.g., Device1)">
        <input type="text" id="target-peer-id" placeholder="Target Peer ID to Connect">
        <button id="connect-btn">Connect</button>
        <p id="connection-status">Not Connected</p>
        <div id="log" class="log"></div>
    </div>

    <div id="file-section" style="display:none;">
        <h2>File Transfer</h2>
        <input type="file" id="file-input" multiple>
        <button id="send-file-btn" disabled>Send File(s)</button>
        
        <div id="file-list">
            <h3>Received Files:</h3>
            <ul id="received-files"></ul>
        </div>
    </div>

    <script>
    class WebRTCFileSharing {
        constructor() {
            this.CHUNK_SIZE = 64 * 1024;
            
            this.initializeDOMElements();
            this.initializeEventListeners();
            
            this.peer = null;
            this.connection = null;
            this.receivedFiles = [];
            this.currentFileBuffer = [];
            this.currentFileInfo = null;
            this.fileTransferProgress = {};

            // Initialize TURN servers first
            this.initializeXirsysTurnServers().then(() => {
                this.log('TURN servers initialized successfully', 'success');
            }).catch(error => {
                this.log('Failed to initialize TURN: ' + error.message, 'error');
            });
        }

        async initializeXirsysTurnServers() {
            try {
                this.log('Fetching TURN servers from Xirsys...', 'info');
                
                const response = await fetch('https://global.xirsys.net/_turn/TreggWEBRTC', {
                    method: 'PUT',
                    headers: {
                        'Authorization': 'Basic ' + btoa("TreggJr:f6bc9368-f6b8-11ef-97c7-0242ac150003"),
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({"format": "urls"})
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                }

                const data = await response.json();
                console.log('Xirsys API Response:', data);
                
                if (!data.v || !data.v.iceServers) {
                    throw new Error('Unexpected Xirsys response format');
                }

                const iceServers = data.v.iceServers;
                const turnServers = iceServers.urls.map(url => ({
                    urls: url,
                    username: iceServers.username,
                    credential: iceServers.credential
                }));

                this.configuration = {
                    iceServers: [
                        ...turnServers,
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                };

                this.log(`Loaded ${turnServers.length} TURN servers`, 'success');
                console.log('Configured ICE Servers:', this.configuration.iceServers);
                
            } catch (error) {
                console.error('TURN server initialization failed:', error);
                this.log('Using fallback STUN servers: ' + error.message, 'warning');
                this.configuration = {
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                };
            }
        }

        initializeDOMElements() {
            this.peerIdInput = document.getElementById('peer-id');
            this.targetPeerIdInput = document.getElementById('target-peer-id');
            this.connectBtn = document.getElementById('connect-btn');
            this.connectionStatus = document.getElementById('connection-status');
            this.logElement = document.getElementById('log');
            this.fileSection = document.getElementById('file-section');
            this.fileInput = document.getElementById('file-input');
            this.sendFileBtn = document.getElementById('send-file-btn');
            this.receivedFilesList = document.getElementById('received-files');
        }

        log(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEntry.classList.add(type);
            this.logElement.appendChild(logEntry);
            this.logElement.scrollTop = this.logElement.scrollHeight;
            console.log(message);
        }

        initializeEventListeners() {
            this.connectBtn.addEventListener('click', () => {
                const peerId = this.peerIdInput.value.trim();
                const targetPeerId = this.targetPeerIdInput.value.trim();
                
                if (peerId) {
                    this.initializePeerConnection(peerId, targetPeerId);
                } else {
                    this.log('Please enter a Peer ID', 'error');
                }
            });

            this.sendFileBtn.addEventListener('click', () => {
                const files = this.fileInput.files;
                if (files.length > 0 && this.connection && this.connection.open) {
                    Array.from(files).forEach(file => this.sendFile(file));
                }
            });
        }

        initializePeerConnection(peerId, targetPeerId) {
            if (this.peer) {
                this.peer.destroy();
            }

            this.peer = new Peer(peerId, {
                config: this.configuration
            });

            this.peer.on('open', (id) => {
                this.log(`Connected with Peer ID: ${id}`, 'success');
                
                if (targetPeerId) {
                    this.connectToPeer(targetPeerId);
                }
            });

            this.peer.on('connection', (conn) => {
                this.handleConnection(conn);
            });

            this.peer.on('error', (error) => {
                this.log(`Peer Error: ${error}`, 'error');
            });
        }

        connectToPeer(targetPeerId) {
            this.connection = this.peer.connect(targetPeerId, {
                reliable: true
            });
            this.handleConnection(this.connection);
        }

        handleConnection(conn) {
            this.connection = conn;
            
            conn.on('open', () => {
                this.connectionStatus.textContent = 'Connected';
                this.sendFileBtn.disabled = false;
                this.fileSection.style.display = 'block';
                this.log('Connected to peer', 'success');
            });

            conn.on('data', (data) => {
                this.handleIncomingMessage(data);
            });

            conn.on('close', () => {
                this.connectionStatus.textContent = 'Disconnected';
                this.sendFileBtn.disabled = true;
                this.log('Connection closed', 'warning');
            });

            conn.on('error', (error) => {
                this.log(`Connection error: ${error}`, 'error');
            });
        }

        async sendFile(file) {
            if (!this.connection || !this.connection.open) {
                this.log('Connection is not open', 'error');
                return;
            }

            const fileInfo = {
                name: file.name,
                size: file.size,
                type: file.type
            };

            this.fileTransferProgress[fileInfo.name] = {
                sent: 0,
                total: fileInfo.size
            };

            // Send file info first
            this.connection.send({
                type: 'fileInfo',
                data: fileInfo
            });

            try {
                let offset = 0;
                const reader = new FileReader();
                
                // Convert FileReader to Promise-based operation
                const readChunk = (start, end) => {
                    return new Promise((resolve, reject) => {
                        const slice = file.slice(start, end);
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = () => reject(reader.error);
                        reader.readAsArrayBuffer(slice);
                    });
                };

                // Process chunks iteratively instead of recursively
                while (offset < file.size) {
                    const end = Math.min(offset + this.CHUNK_SIZE, file.size);
                    const chunk = await readChunk(offset, end);
                    
                    // Convert chunk to Uint8Array and then to regular array
                    const chunkArray = Array.from(new Uint8Array(chunk));
                    
                    // Send chunk in smaller pieces if needed
                    const maxChunkSize = 16000; // Smaller chunk size to prevent stack overflow
                    for (let i = 0; i < chunkArray.length; i += maxChunkSize) {
                        const subChunk = chunkArray.slice(i, i + maxChunkSize);
                        this.connection.send({
                            type: 'fileChunk',
                            name: fileInfo.name,
                            data: subChunk,
                            offset: offset + i
                        });
                    }

                    offset = end;
                    this.fileTransferProgress[fileInfo.name].sent = offset;

                    const progressPercentage = Math.round((offset / file.size) * 100);
                    this.log(`Sending ${fileInfo.name}: ${progressPercentage}%`, 'info');
                }

                this.log(`File ${fileInfo.name} sent completely`, 'success');
                
            } catch (error) {
                this.log(`Error sending file: ${error.message}`, 'error');
            }
        }

        handleIncomingMessage(message) {
            try {
                switch(message.type) {
                    case 'fileInfo':
                        this.currentFileInfo = message.data;
                        this.currentFileBuffer = new Uint8Array(this.currentFileInfo.size);
                        this.currentBufferOffset = 0;
                        
                        const progressContainer = document.createElement('div');
                        progressContainer.id = `progress-${this.currentFileInfo.name}`;
                        progressContainer.innerHTML = `
                            <p>Receiving: ${this.currentFileInfo.name}</p>
                            <div class="progress-bar">
                                <div class="progress-bar-fill" style="width: 0%"></div>
                            </div>
                        `;
                        this.receivedFilesList.appendChild(progressContainer);
                        
                        this.log(`Receiving file: ${this.currentFileInfo.name}`, 'info');
                        break;
                        
                    case 'fileChunk':
                        if (this.currentFileInfo && this.currentFileBuffer) {
                            // Convert chunk array back to Uint8Array and copy to the correct position
                            const chunk = new Uint8Array(message.data);
                            this.currentFileBuffer.set(chunk, message.offset);
                            this.currentBufferOffset = Math.max(this.currentBufferOffset, message.offset + chunk.length);
                            
                            const progressBar = document.querySelector(`#progress-${this.currentFileInfo.name} .progress-bar-fill`);
                            const progressPercentage = Math.round((this.currentBufferOffset / this.currentFileInfo.size) * 100);
                            if (progressBar) {
                                progressBar.style.width = `${progressPercentage}%`;
                            }
                            
                            if (this.currentBufferOffset >= this.currentFileInfo.size) {
                                this.saveReceivedFile();
                            }
                        }
                        break;
                }
            } catch (error) {
                this.log(`Message handling error: ${error}`, 'error');
            }
        }

        saveReceivedFile() {
            const blob = new Blob([this.currentFileBuffer], { type: this.currentFileInfo.type });
            const url = URL.createObjectURL(blob);
            
            const progressContainer = document.getElementById(`progress-${this.currentFileInfo.name}`);
            if (progressContainer) {
                progressContainer.remove();
            }
            
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = url;
            link.download = this.currentFileInfo.name;
            link.textContent = `${this.currentFileInfo.name} (${this.formatFileSize(this.currentFileInfo.size)})`;
            listItem.appendChild(link);
            
            this.receivedFilesList.appendChild(listItem);
            
            this.receivedFiles.push(this.currentFileInfo);
            this.currentFileInfo = null;
            this.currentFileBuffer = null;
            this.currentBufferOffset = 0;
            
            this.log(`File ${link.download} received successfully`, 'success');
        }

        formatFileSize(bytes) {
            if (bytes < 1024) return `${bytes} bytes`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
            return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        new WebRTCFileSharing();
    });
    </script>
</body>
</html>